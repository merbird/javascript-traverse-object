{"version":3,"sources":["../src/js/objectTraverse.js"],"names":["checkObjectMatch","nestedObj","pathArr","reduce","obj","key","undefined","level","matchedSelect","traverseObject","map","select","matchAll","paddingChars","repeat","hasOwnProperty","length","push","curMatchedSelect","slice","Array","isArray","console","log"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,mBAAmB,CAACC,SAAD,EAAYC,OAAZ,KAAwB;AAC9C,UAAOA,QAAQC,MAAR,CAAe,CAACC,GAAD,EAAMC,GAAN,KAAc;AACjC,aAAQD,OAAOA,IAAIC,GAAJ,MAAa,WAArB,GAAoCD,IAAIC,GAAJ,CAApC,GAA+CC,SAAtD;AACF,IAFM,EAEJL,SAFI,CAAP;AAGF,CAJD;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIM,QAAQ,CAAZ;AACA,IAAIC,gBAAgB,KAApB;AACA,OAAO,SAASC,cAAT,CAAwBL,GAAxB,EAA6B,EAAEM,MAAM,KAAR,EAAeC,SAAS,EAAxB,EAA4BC,WAAW,KAAvC,EAA7B,EAA6E;;AAEjF,OAAIL,UAAU,CAAd,EAAiBC,gBAAgB,KAAhB;AACjB,OAAIK,eAAgBN,UAAU,CAAX,GAAgB,EAAhB,GAAqB,MAAMO,MAAN,CAAaP,KAAb,CAAxC;;AAEA,QAAK,IAAIF,GAAT,IAAgBD,GAAhB,EAAqB;;AAElB;AACA,UAAIA,IAAIW,cAAJ,CAAmBV,GAAnB,CAAJ,EAA6B;;AAE1B;AACA;AACA;;AAEA,aAAK,CAACO,QAAD,IAAa,CAACJ,aAAf,IAAiCI,QAArC,EAA+C;AAC5C,gBAAID,UAAUA,OAAOK,MAAP,GAAgB,CAA1B,IAA+BX,OAAOM,OAAO,CAAP,CAA1C,EAAqD;AAClD,mBAAIA,OAAOK,MAAP,KAAkB,CAAtB,EAAyB;;AAEtB,sBAAI,CAACR,aAAL,EAAoBA,gBAAgB,EAAhB;AACpBA,gCAAcS,IAAd,CAAmBb,IAAIC,GAAJ,CAAnB;AAEF,gBALD,MAKO;;AAEJ,sBAAIa,mBAAmBlB,iBAAiBI,IAAIC,GAAJ,CAAjB,EAA2BM,OAAOQ,KAAP,CAAa,CAAb,CAA3B,CAAvB;AACA,sBAAID,gBAAJ,EAAsB;AACnB,yBAAI,CAACV,aAAL,EAAoBA,gBAAgB,EAAhB;AACpBA,mCAAcS,IAAd,CAAmBC,gBAAnB;AACF;AAEH;;AAED,mBAAIV,iBAAiB,CAACI,QAAlB,IAA8B,CAACF,GAAnC,EAAwC;AACrC,yBAAOF,aAAP;AACF;AACH;AACH;;AAED;AACA;AACA,aAAI,OAAOJ,IAAIC,GAAJ,CAAP,KAAoB,QAApB,IAAgCD,IAAIC,GAAJ,MAAa,IAAjD,EAAuD;AACpD,gBAAIe,MAAMC,OAAN,CAAcjB,IAAIC,GAAJ,CAAd,CAAJ,EAA6B;AAC1B,mBAAIK,GAAJ,EAAS;AAAEY,0BAAQC,GAAR,CAAa,GAAEV,YAAa,SAAQR,GAAI,EAAxC;AAA4C;AAEzD,aAHD,MAGO;AACJ,mBAAIK,GAAJ,EAAS;AAAEY,0BAAQC,GAAR,CAAa,GAAEV,YAAa,UAASR,GAAI,EAAzC;AAA6C;AAC1D;;AAEDE;AACAC,4BAAgBC,eAAeL,IAAIC,GAAJ,CAAf,EAAyB,EAAEK,GAAF,EAAOC,MAAP,EAAeC,QAAf,EAAzB,CAAhB;AACA;AACA,gBAAIJ,iBAAiB,CAACI,QAAlB,IAA8B,CAACF,GAAnC,EAAwC;AACrC,sBAAOF,aAAP;AACF;;AAED;AACA;AACAD;AAEF,UAnBD,MAmBO;AACJ,gBAAIG,GAAJ,EAAS;AAAEY,uBAAQC,GAAR,CAAa,GAAEV,YAAa,OAAMR,GAAI,YAAWD,IAAIC,GAAJ,CAAS,EAA1D;AAA8D;AAC3E;AACH;AACH;AACD,UAAOG,aAAP;AACF","file":"objectTraverse.js","sourcesContent":["// Checks the specified elements path exists in the obj and if so returns the match\r\n// ------ Parameters --------------\r\n// nestedObj - object - object to check\r\n// pathArr - array - list of elements used to match \r\n// ---------- Return --------------- \r\n// Matched element in obj or undefined \r\nconst checkObjectMatch = (nestedObj, pathArr) => {\r\n   return pathArr.reduce((obj, key) => {\r\n      return (obj && obj[key] !== 'undefined') ? obj[key] : undefined\r\n   }, nestedObj);\r\n}\r\n\r\n// Traverse any object by the use of recursive function. You can also pass in a list of\r\n// elements on which to perform a selection. \r\n// For example, \r\n//     'select = ['relatives', 0, 'relation']' = relatives[0].relation\r\n//     'select = ['address', 'city']' = address.city\r\n// Note select does not have to start at root element\r\n// ------ Parameters --------------\r\n// obj - object - object to traverse\r\n// options - object containing optional parameters defining how traverse works \r\n//      map - bool - if true display map of obj in console\r\n//      select - array - list of elements used to match \r\n//      matchAll - bool - false return first match, true return all matches\r\n// ---------- Return ---------------\r\n// array - list of matched elements or false if no elements matched\r\nlet level = 0;\r\nlet matchedSelect = false\r\nexport function traverseObject(obj, { map = false, select = [], matchAll = false }) {\r\n\r\n   if (level === 0) matchedSelect = false;\r\n   let paddingChars = (level === 0) ? '' : '---'.repeat(level);\r\n\r\n   for (let key in obj) {\r\n\r\n      // use hasOwnProperty to skip over inherited properties\r\n      if (obj.hasOwnProperty(key)) {\r\n\r\n         // If select is populated then we need to check for pattern match\r\n         // Checks current object key value against first set of criteria \r\n         // to see if we are at the point to start selection extraction\r\n\r\n         if ((!matchAll && !matchedSelect) || matchAll) {\r\n            if (select && select.length > 0 && key == select[0]) {\r\n               if (select.length === 1) {\r\n\r\n                  if (!matchedSelect) matchedSelect = [];\r\n                  matchedSelect.push(obj[key]);\r\n\r\n               } else {\r\n\r\n                  let curMatchedSelect = checkObjectMatch(obj[key], select.slice(1));\r\n                  if (curMatchedSelect) {\r\n                     if (!matchedSelect) matchedSelect = [];\r\n                     matchedSelect.push(curMatchedSelect);\r\n                  }\r\n\r\n               }\r\n\r\n               if (matchedSelect && !matchAll && !map) {\r\n                  return matchedSelect;\r\n               }\r\n            }\r\n         }\r\n\r\n         // if we have an array or object we need to keep traversing \r\n         // down the object\r\n         if (typeof obj[key] === 'object' && obj[key] !== null) {\r\n            if (Array.isArray(obj[key])) {\r\n               if (map) { console.log(`${paddingChars}Array ${key}`) };\r\n\r\n            } else {\r\n               if (map) { console.log(`${paddingChars}Object ${key}`) };\r\n            }\r\n\r\n            level++;\r\n            matchedSelect = traverseObject(obj[key], { map, select, matchAll });\r\n            // not mapping and found match then return\r\n            if (matchedSelect && !matchAll && !map) {\r\n               return matchedSelect;\r\n            }\r\n\r\n            // returned from processing higher level so revert back to\r\n            // lower level\r\n            level--;\r\n\r\n         } else {\r\n            if (map) { console.log(`${paddingChars}key ${key} : value ${obj[key]}`) };\r\n         }\r\n      }\r\n   }\r\n   return matchedSelect;\r\n}"]}